# ____________________________________________________________________________________
#
# Pyomo: Python Optimization Modeling Objects
# Copyright (c) 2008-2026 National Technology and Engineering Solutions of Sandia, LLC
# Under the terms of Contract DE-NA0003525 with National Technology and Engineering
# Solutions of Sandia, LLC, the U.S. Government retains certain rights in this
# software.  This software is distributed under the 3-clause BSD License.
# ____________________________________________________________________________________
"""This module provides general utilities for producing formatted I/O

.. autosummary::

   tostr
   tabular_writer
   wrap_reStructuredText
   StreamIndenter
"""

import io
import re
import sys
import types

from collections import defaultdict
from itertools import chain
from typing import Iterable

from pyomo.common.sorting import sorted_robust


def tostr(value, quote_str=False):
    """Convert a value to a string

    This function is a thin wrapper around `str(value)` to resolve a
    problematic __str__ implementation in the standard Python container
    types (tuple, list, and dict).  Those classes implement __str__ the
    same as __repr__ (by calling repr() on each contained object).  That
    is frequently undesirable, as you may wish the string representation
    of a container to contain the string representations of the
    contained objects.

    This function generates string representations for native Python
    containers (tuple, list, and dict) that contains the string
    representations of the contained objects.  In addition, it also
    applies the same special handling to any types that derive from the
    standard containers without overriding either __repn__ or __str__.

    Parameters
    ----------
    value: object
        the object to convert to a string
    quote_str: bool
        if True, and if `value` is a `str`, then return a "quoted
        string" (as generated by repr()).  This is primarily used when
        recursively processing native Python containers.

    Returns
    -------
    str

    """
    # Override the generation of str(list), but only if the object is
    # using the default implementation of list.__str__.  Note that the
    # default implementation of __str__ (in CPython) is to call __repr__,
    # so we will test both.  This is particularly important for
    # collections.namedtuple, which reimplements __repr__ but not
    # __str__.
    _type = type(value)
    if _type not in tostr.handlers:
        # Default to the None handler (just call str()), but override it
        # in particular instances:
        tostr.handlers[_type] = tostr.handlers[None]
        if isinstance(value, list):
            if _type.__str__ is list.__str__ and _type.__repr__ is list.__repr__:
                tostr.handlers[_type] = tostr.handlers[list]
        elif isinstance(value, tuple):
            if _type.__str__ is tuple.__str__ and _type.__repr__ is tuple.__repr__:
                tostr.handlers[_type] = tostr.handlers[tuple]
        elif isinstance(value, dict):
            if _type.__str__ is dict.__str__ and _type.__repr__ is dict.__repr__:
                tostr.handlers[_type] = tostr.handlers[dict]
        elif isinstance(value, str):
            tostr.handlers[_type] = tostr.handlers[str]

    return tostr.handlers[_type](value, quote_str)


tostr.handlers = {
    list: lambda value, quote_str: (
        "[%s]" % (', '.join(tostr(v, True) for v in value))
    ),
    dict: lambda value, quote_str: (
        "{%s}"
        % (
            ', '.join(
                '%s: %s' % (tostr(k, True), tostr(v, True)) for k, v in value.items()
            )
        )
    ),
    tuple: lambda value, quote_str: (
        "(%s,)" % (tostr(value[0], True),)
        if len(value) == 1
        else "(%s)" % (', '.join(tostr(v, True) for v in value))
    ),
    str: lambda value, quote_str: (repr(value) if quote_str else value),
    None: lambda value, quote_str: str(value),
}


# Literals are used in parsing string names (and indicate tuples,
# indexing, and token separators)
name_literals = '()[],.'
# Special characters are additional characters that if they appear in
# the string force us to quote the string.  This includes the obvious
# things like single and double quote characters, but also backslash
# (indicates that the string contains escaped - possibly unicode -
# characters), and the colon (used as a token separator in the old
# ComponentUID "v1" format).
name_special_chars = name_literals + '\'":\\'

re_number = re.compile(
    r'(?:[-+]?(?:[0-9]+\.?[0-9]*|\.[0-9]+)(?:[eE][-+]?[0-9]+)?|-?inf|nan)'
)
re_name_special_char = re.compile(r'[' + re.escape(name_special_chars) + ']')


def name_repr(x, unknown_handler=str):
    """Generate a "friendly" string representation of a Pyomo name.

    Convert ``x`` into a "user-friendly" string.  Numbers are converted
    to strings.  Strings are left unquoted, *unless* the string contains
    a "special" character that is used in parsing Pyomom component names
    (currently any of ``{name_special_chars}``) or the string could be
    interpreted as a number.

    """
    _repr = _repr_map.get(x.__class__, None)
    if _repr is not None:
        return _repr(x)
    elif not isinstance(x, str):
        return unknown_handler(x)

    # Special handling for strings: only quote the string if it contains
    # "special" characters or looks like a number
    quoted = repr(x)
    if quoted[1] == '|':
        return quoted
    unquoted = quoted[1:-1]
    if re_name_special_char.search(unquoted):
        return quoted
    if re_number.fullmatch(unquoted):
        return quoted
    return unquoted


def tuple_repr(x, unknown_handler=str):
    return (
        '('
        + ','.join(name_repr(_, unknown_handler) for _ in x)
        + (',)' if len(x) == 1 else ')')
    )


def index_repr(idx, unknown_handler=str):
    """Return a string representation of an index.

    This will nominally return the :func:`name_repr` for the elements of
    ``idx``.  For 1-tuples, the parens are omittted unless the tuple is
    empty.

    Note that the brackets (``[]``) normally associated with Pyomo
    indexes are *not* included in the resulting string.

    """
    if idx.__class__ is tuple and len(idx) > 1:
        return ",".join(name_repr(i, unknown_handler) for i in idx)
    return name_repr(idx, unknown_handler)


# Note: do not add str to this map: it gets special handling in
# name_repr (and that logic relies on it not being in this map)
_repr_map = {
    slice: lambda x: '*',
    Ellipsis.__class__: lambda x: '**',
    int: repr,
    float: repr,
    tuple: tuple_repr,
}


def _pad_row(row, n):
    if len(row) < n:
        return row + ('',) * (n - len(row))
    return row


def tabular_writer(ostream, prefix, data, header, row_generator):
    """Output data in tabular form

    Parameters
    ----------
    ostream: io.TextIOBase
        the stream to write to
    prefix: str
        prefix each generated line with this string
    data: iterable
        an iterable object that returns (key, value) pairs
        (e.g., from items()) defining each row in the table
    header: list[str]
        list of column headers
    row_generator: Callable[Any, Any]
        a function that accepts the `key` and `value` from `data` and
        returns either a tuple defining the entries for a single row, or
        a generator that returns a sequence of table rows to be output
        for the specified `key`

    """

    if prefix:
        ostream = StreamIndenter(ostream, prefix)

    rows = []
    columns = set()
    if header:
        header = (u"Key",) + tuple(tostr(x) for x in header)
        columns.add(len(header))

    keyfield = ()
    for _key, _val in data:
        if header:
            keyfield = (_key,)
        try:
            rowset = row_generator(_key, _val)
            if isinstance(rowset, types.GeneratorType):
                for i, r in enumerate(rowset):
                    r = tuple(tostr(_) for _ in chain(keyfield, r))
                    rows.append(r)
                    columns.add(len(r))
                    if not i and keyfield:
                        keyfield = ('',)
                if keyfield and keyfield != ('',):
                    rows.append(keyfield)
                    columns.add(len(keyfield))
            else:
                r = tuple(map(tostr, chain(keyfield, rowset)))
                rows.append(r)
                columns.add(len(r))
        except:
            # A ValueError can be raised when row_generator is called
            # (if it is a function), or when it is exhausted generating
            # the list (if it is a generator)
            r = tuple(map(tostr, chain(keyfield, (sys.exc_info()[0].__name__,))))
            rows.append(r)
            columns.add(len(r))
            continue

    nCols = max(columns)
    if len(columns) > 1:
        header = _pad_row(header, nCols)
        rows = [_pad_row(r, nCols) for r in rows]

    if rows:
        _row_width = [max(len(r[i]) for r in rows) for i in range(nCols)]
    else:
        _row_width = defaultdict(int)
    if header:
        _width = [max(_row_width[i], len(header[i])) for i in range(nCols)]
    else:
        _width = _row_width

    # NB: left-justify header entries
    if header:
        # Note: do not right-pad the last header with unnecessary spaces
        line_fmt = " : ".join(f"%-{w}s" for w in _width[:-1]) + " : %s"
        ostream.write((line_fmt % header).rstrip() + "\n")

    # If there is no data, we are done...
    if not rows:
        return

    # right-justify data, except for the last column if there are spaces
    # in the data (probably an expression or vector)
    _width = [f"%{w}s" for w in _width]
    if any(' ' in r[-1] for r in rows):
        _width[-1] = '%s'
    line_fmt = " : ".join(_width) + "\n"

    for r in rows:
        ostream.write((line_fmt % r).rstrip() + "\n")


class StreamIndenter:
    """
    Mock-up of a file-like object that wraps another file-like object
    and indents all data using the specified string before passing it to
    the underlying file.  Since this presents a full file interface,
    StreamIndenter objects may be arbitrarily nested.
    """

    _newline_re = re.compile('\n([^\n])')
    _blankline_re = re.compile('\n\n')

    def __init__(self, ostream: io.TextIOBase, indent: str = ' ' * 4):
        super().__setattr__('wrapped_os', ostream)
        # The following is a "cute" trick: because of the __getattr__ /
        # __setattr__ overloads, nested StreamIndenter instances all
        # print directly to the underlying stream object, and all share
        # a common `newline` flag.
        if isinstance(ostream, StreamIndenter):
            super().__setattr__('target_os', ostream.target_os)
            indent = ostream.indent + indent
        else:
            super().__setattr__('target_os', ostream)
            # We will assume the last thing written to the stream we
            # are wrapping ended with a newline
            super().__setattr__('newline', True)
        super().__setattr__('indent', indent)
        super().__setattr__('indent_match', f'\n{indent}\\1')
        super().__setattr__('stripped_indent', indent.rstrip())
        if self.stripped_indent:
            super().__setattr__('blankline_match', f'\n{self.stripped_indent}\n')

    def __getattr__(self, name: str):
        return getattr(self.wrapped_os, name)

    def __setattr__(self, name: str, val):
        if name in self.__dict__:
            super().__setattr__(name, val)
        else:
            self.wrapped_os.__setattr__(name, val)

    def write(self, data: str) -> int:
        if not data:
            return 0
        written = 0
        if self.newline:
            if data[0] != '\n':
                written += self.target_os.write(self.indent)
            elif self.stripped_indent:
                written += self.target_os.write(self.stripped_indent)
        data = self._newline_re.sub(self.indent_match, data)
        if self.stripped_indent:
            data, n = self._blankline_re.subn(self.blankline_match, data)
            # If we replaced any blank lines, then we need to check
            # again to catch cases like "\n\n\n"
            if n:
                data = self._blankline_re.sub(self.blankline_match, data)
        written += self.target_os.write(data)
        self.newline = data.endswith('\n')
        return written

    def writelines(self, sequence: Iterable[str]) -> None:
        for x in sequence:
            self.write(x)


_indentation_re = re.compile(r'\s*')
_bullet_re = re.compile(
    r'([-+*] +)'  # bulleted lists
    r'|(\(?[0-9]+[\)\.] +)'  # enumerated lists (arabic numerals)
    r'|(\(?[ivxlcdm]+[\)\.] +)'  # enumerated lists (roman numerals)
    r'|(\(?[IVXLCDM]+[\)\.] +)'  # enumerated lists (roman numerals)
    r'|(\(?[a-zA-Z][\)\.] +)'  # enumerated lists (letters)
    r'|(\(?\#[\)\.] +)'  # auto enumerated lists
    r'|(?:\[\s*[A-Za-z0-9\.]+\s*\] +)'  # [PASS]|[FAIL]|[ OK ] (not part of ReST)
)
_literal_start = re.compile(
    r'(>>> )'  # implicit doctest
    r'|(\| )'  # line blocks
    r'|(={3,}[ =]+)'  # simple tables, ======== sections
    r'|(\+((-{3,})|(={3,}))\+)'  # grid table
)
_literal_line = re.compile(
    # sections
    '|'.join(r'(\%s{3,})' % c for c in r'!"#$%&\'()*+,-./:;<>?@[\\]^_`{|}~')
)
_field_list = re.compile(r':((\:)|(\\(?!:))|[^:\\])+: ')
_directive_re = re.compile(r'\.\. +([\[_]|.*::)')
_wrappable_directives = {
    "admonition::",
    "attention::",
    "caution::",
    "danger::",
    "error::",
    "hint::",
    "important::",
    "note::",
    "tip::",
    "warning::",
    "contents::",
    "replace::",
}
_literal_directives = {
    "code::",
    "line-block::",
    "parsed-literal::",
    "math::",
    "table::",
    "csv-table::",
    "list-table::",
    "raw::",
    "doctest::",
    "testsetup::",
    "testcode::",
    "testoutput::",
}


def wrap_reStructuredText(docstr, wrapper, tabsize=8, default_hang=3):
    """A text wrapper that honors paragraphs and basic reStructuredText markup

    This wraps `textwrap.fill()` to first separate the incoming text by
    paragraphs before using ``wrapper`` to wrap each one.  It includes a
    basic (partial) parser for reStructuredText format to attempt to
    avoid wrapping structural elements like section headings, bullet /
    enumerated lists, and tables.

    Parameters
    ----------
    docstr : str
        The incoming string to parse and wrap

    wrapper : textwrap.TextWrap
        The configured :class:`TextWrap` object to use for wrapping
        paragraphs.  While the object will be reconfigured within this
        function, it will be restored to its original state upon exit.

    tabsize : int
        tab characters in `docstr` will be converted to this many spaces

    default_hang : int
        Long paragraphs that are part of terms that support wrapping
        using hanging indentation (e.g., admonitions) will use hanging
        indents of this many spaces if we cannot infer the hanging
        indent (e.g., from a subsequent line or the enumeration marker).

    """
    # As textwrap only works on single paragraphs, we need to break
    # up the incoming message into paragraphs before we pass it to
    # textwrap.

    # indent is the indentation level for the current paragraph
    indent: int = 0
    # hang is the hanging indent level for the current paragraph - that
    # is, the indentation level for all lines other than the first.  If
    # it is "None", then the hanging level is yet to be determined.  In
    # that case, hang must be greater than indent, unless we are in a
    # literal block (where they are allowed to be at the same level as
    # the main paragraph indentation)
    hang: int | None = 0
    paragraphs = [(0, 0, None)]
    literal_block = False
    verbatim = False
    docstr = docstr.replace('\t', ' ' * tabsize).rstrip(' ')
    for line in docstr.splitlines():
        leading = len(_indentation_re.match(line).group())
        content = line.strip()
        if not content:
            if not (literal_block and hang != indent):
                # Unless this is an "indented literal block", then we
                # want to clear the literal flag
                literal_block = False
            paragraphs.append((indent, hang, None))
            continue
        if hang is None and (leading > indent or (literal_block and leading == indent)):
            hang = leading
            paragraphs[-1] = (indent, hang, paragraphs[-1][2])

        if literal_block:
            if leading > indent and hang > indent:
                # Indented literal block
                paragraphs.append((None, None, line))
                continue
            elif leading == hang:
                if literal_block == True:
                    # Arbitrary blank-line-terminated literal
                    paragraphs.append((None, None, line))
                    continue
                elif literal_block == 'literal':
                    if content[0] in '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~':
                        literal_block = content[0]
                        paragraphs.append((None, None, line))
                        continue
                elif content[0] in literal_block:
                    # we are still in a quoted literal block (and the
                    # leading character matches)
                    paragraphs.append((None, None, line))
                    continue
            # It looks like we have exited the literal block.  Reset
            # the context and fall back on normal line processing
            literal_block = False

        indent = leading
        if content == '```':
            # Not part of ReST, but we have supported this in Pyomo for
            # a long time.  Note that this implementation strips the
            # "```" lines from the output.
            verbatim ^= True
        elif verbatim:
            paragraphs.append((None, None, line))
        elif content.startswith('..') and content[2:3] in (' ', ''):
            if content == '..':
                # blank comment
                paragraphs.append((None, None, line))
                continue
            cmd = _directive_re.match(content)
            if cmd:
                cmd = cmd.group(1)
                if cmd in '_[':
                    # footnote / citation / hyperlink
                    hang = None
                    paragraphs.append((indent, None, [content]))
                    # An explicit marker (directive)
                    pass
                elif cmd in _wrappable_directives:
                    hang = None
                    paragraphs.append((indent, None, [content]))
                elif cmd in _literal_directives:
                    literal_block = True
                    hang = None
                    paragraphs.append((None, None, line))
                else:
                    paragraphs.append((None, None, line))
            else:
                # This is a comment
                hang = None
                paragraphs.append((indent, None, [content]))
        elif content.startswith('__ '):
            # anonymous hyperlinks
            hang = None
            paragraphs.append((indent, None, [content]))
        elif _literal_start.match(content):
            # This catches lines that start with patterns that indicate
            # the start of a literal block that should continue until
            # the first blank line (line blocks, doctest blocks, grid
            # tables, simple tables)
            hang = leading
            literal_block = True
            paragraphs.append((None, None, line))
        elif _literal_line.match(content):
            # This catches single line patterns that should not be
            # wrapped with previous/subsequent lines (e.g., section
            # headers)
            paragraphs.append((None, None, line))
        elif matchBullet := _bullet_re.match(content):
            # Handle things that look like bullet lists specially
            hang = leading + len(matchBullet.group())
            paragraphs.append((indent, hang, [content]))
        elif _field_list.match(content):
            hang = None
            paragraphs.append((indent, hang, [content]))
        else:
            if leading == hang:
                # Continuing a text block
                try:
                    paragraphs[-1][2].append(content)
                except AttributeError:
                    paragraphs.append((indent, hang, [content]))
            else:
                if hang is not None and leading > hang:
                    # Definitions: a single line term (that may or may
                    # not have a ":" followed by one or more
                    # classifiers) followed immediately by an indented
                    # block.  Do not wrap the single line
                    i, h, c = paragraphs[-1]
                    if i == h and type(c) is list and len(c) == 1:
                        paragraphs[-1] = (i, h, c[0])

                # Beginning a new text block
                hang = indent
                paragraphs.append((indent, hang, [content]))

            if content.endswith('::'):
                # If the literal block looks like it was the end of a
                # paragraph, support re-wrapping.  Note that things that
                # look like directives (explicit markers) have already
                # been caught.
                hang = None
                literal_block = 'literal'

    # Strip off any leading newlines...
    # while paragraphs and paragraphs[0][2] is None:
    #    paragraphs.pop(0)
    paragraphs = paragraphs[1:]
    orig_indent = wrapper.initial_indent
    orig_subsequent = wrapper.subsequent_indent
    try:
        for i, (indent, subseq, par) in enumerate(paragraphs):
            if par.__class__ is list:
                if subseq is None:
                    # This paragraph is allowed to be wrapped with a
                    # hanging indent, but the source data only had a
                    # single line.
                    subseq = default_hang
                # Update the wrapper with this paragraph's indentation
                wrapper.initial_indent += ' ' * indent
                wrapper.subsequent_indent += ' ' * subseq
                paragraphs[i] = wrapper.fill(' '.join(par))
            elif par is None:
                paragraphs[i] = wrapper.initial_indent.rstrip()
            else:
                paragraphs[i] = wrapper.initial_indent + par
            # Restore the wrapper, but note that the next iteration is
            # no longer the first line, so the initial and subsequent
            # indent should be the original subsequent indent
            wrapper.initial_indent = wrapper.subsequent_indent = orig_subsequent
    finally:
        # Avoid side-effects and restore the initial wrapper state
        wrapper.initial_indent = orig_indent
        wrapper.subsequent_indent = orig_subsequent

    ans = '\n'.join(paragraphs)
    if ans and docstr.endswith('\n') and not paragraphs[-1].endswith('\n'):
        ans += '\n'
    return ans
